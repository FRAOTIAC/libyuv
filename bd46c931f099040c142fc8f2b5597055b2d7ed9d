{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "2302e206_99b2e097",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2022-12-21T21:53:22Z",
      "side": 1,
      "message": "Looks much better thanks.  I expect even in C that this performs reasonably well.",
      "revId": "bd46c931f099040c142fc8f2b5597055b2d7ed9d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "eab01c2e_79ca0e27",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2022-12-21T23:37:56Z",
      "side": 1,
      "message": "Performance on Skylake Xeon\nI210Rotate90_Opt (1429 ms)\nI410Rotate90_Opt (1232 ms)\nI422Rotate90_Opt (878 ms)\nARGBRotate90_Opt (794 ms)\nI010Rotate90_Opt (625 ms)\nI444Rotate90_Opt (597 ms)\nNV12Rotate90_Opt (304 ms)\nI420Rotate90_Opt (295 ms)\nRotatePlane90_Opt (195 ms)\n\nPerformance on Pixel 4 (Cortex A76)\nARGBRotate90_Opt (2559 ms)\nI410Rotate90_Opt (2348 ms)\nI210Rotate90_Opt (2193 ms)\nI422Rotate90_Opt (1209 ms)\nI010Rotate90_Opt (843 ms)\nI444Rotate90_Opt (706 ms)\nNV12Rotate90_Opt (285 ms)\nI420Rotate90_Opt (274 ms)\nRotatePlane90_Opt (177 ms)\n\nCould you add RotatePlane16_90_Opt benchmark?\nFor large images (this is 1280x720) performance should be 2x slower than 8 bit.  Same number of instructions, but 2x larger data.\nI420 is 274 ms, so I010 should be 274 * 2 \u003d 548 ms.\nCurrently it is 843 ms, so 65% efficient.\n\nProfiling Rotate 180 on Pixel 4\n65.22%,  MirrorRow_16_C\n22.48%,  __memcpy\n\nYou could use the existing MirrorUVRow_NEON\nwhich is used for NV12 UV and does 2 bytes at a time.  But probably a new function should be made, or at least a macro, and use uint16_t for the pointer.",
      "revId": "bd46c931f099040c142fc8f2b5597055b2d7ed9d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a078b6d2_ffc42081",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1208520
      },
      "writtenOn": "2022-12-22T08:01:30Z",
      "side": 1,
      "message": "Solve the compilation issue about the missing return",
      "revId": "bd46c931f099040c142fc8f2b5597055b2d7ed9d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "48e0c283_7cb9d349",
        "filename": "include/libyuv/rotate.h",
        "patchSetId": 3
      },
      "lineNbr": 223,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2022-12-21T21:52:54Z",
      "side": 1,
      "message": "these low levels can be private... remove from here, make static in the rotate code.  They should also implement as trivial wrappers to transpose, so you might not even bother with functions for 90 and 270.\n\n180 is unique.  It uses a mirror row function but 2 rows at a time with a temporary, allowing in-place rotate.  Its one of the easiest to optimize arm/avx for, if it hasnt already.",
      "revId": "bd46c931f099040c142fc8f2b5597055b2d7ed9d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "66e8ab1a_1bb8445e",
        "filename": "include/libyuv/rotate.h",
        "patchSetId": 3
      },
      "lineNbr": 223,
      "author": {
        "id": 1208520
      },
      "writtenOn": "2022-12-22T08:01:30Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "48e0c283_7cb9d349",
      "revId": "bd46c931f099040c142fc8f2b5597055b2d7ed9d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1b7c689a_b86895ed",
        "filename": "source/rotate_common.cc",
        "patchSetId": 3
      },
      "lineNbr": 169,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2022-12-21T21:52:54Z",
      "side": 1,
      "message": "optional.  this was for NV12 to I420 with rotation.\nIf we do the exquivalent, it would be P016 To I016.  I say 16 because P010 uses msb but I010 uses lsb and needs a shift.\n\nBut for NV12 I would like to move away from this split function and have an NV12Rotate that rotates the UV using RotatePlane_16()",
      "revId": "bd46c931f099040c142fc8f2b5597055b2d7ed9d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "936674f3_a6baff4f",
        "filename": "source/rotate_common.cc",
        "patchSetId": 3
      },
      "lineNbr": 169,
      "author": {
        "id": 1208520
      },
      "writtenOn": "2022-12-22T08:01:30Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "1b7c689a_b86895ed",
      "revId": "bd46c931f099040c142fc8f2b5597055b2d7ed9d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9158c9b0_0be0426a",
        "filename": "unit_test/rotate_test.cc",
        "patchSetId": 3
      },
      "lineNbr": 643,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2022-12-21T21:52:54Z",
      "side": 1,
      "message": "optional. note that this sort of test only tests SIMD row functions vs C.  The high level logic is not tested well.\nIts an easy test and useful, but a better test compares a single test function against something that achieves the same result using 2 steps.\nFor example, you could rotate twice vs once.\nOr you could rotate 10 bit and compare to rotate 8 bit, with a conversion from 10 to 8.  This might not work for a subsampled format when the width is odd.\nYou can also do a very simple test with known values and compare against expected results.",
      "revId": "bd46c931f099040c142fc8f2b5597055b2d7ed9d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}