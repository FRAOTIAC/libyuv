{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "2302e206_99b2e097",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2022-12-21T21:53:22Z",
      "side": 1,
      "message": "Looks much better thanks.  I expect even in C that this performs reasonably well.",
      "revId": "bd46c931f099040c142fc8f2b5597055b2d7ed9d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "48e0c283_7cb9d349",
        "filename": "include/libyuv/rotate.h",
        "patchSetId": 3
      },
      "lineNbr": 223,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2022-12-21T21:52:54Z",
      "side": 1,
      "message": "these low levels can be private... remove from here, make static in the rotate code.  They should also implement as trivial wrappers to transpose, so you might not even bother with functions for 90 and 270.\n\n180 is unique.  It uses a mirror row function but 2 rows at a time with a temporary, allowing in-place rotate.  Its one of the easiest to optimize arm/avx for, if it hasnt already.",
      "revId": "bd46c931f099040c142fc8f2b5597055b2d7ed9d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1b7c689a_b86895ed",
        "filename": "source/rotate_common.cc",
        "patchSetId": 3
      },
      "lineNbr": 169,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2022-12-21T21:52:54Z",
      "side": 1,
      "message": "optional.  this was for NV12 to I420 with rotation.\nIf we do the exquivalent, it would be P016 To I016.  I say 16 because P010 uses msb but I010 uses lsb and needs a shift.\n\nBut for NV12 I would like to move away from this split function and have an NV12Rotate that rotates the UV using RotatePlane_16()",
      "revId": "bd46c931f099040c142fc8f2b5597055b2d7ed9d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9158c9b0_0be0426a",
        "filename": "unit_test/rotate_test.cc",
        "patchSetId": 3
      },
      "lineNbr": 643,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2022-12-21T21:52:54Z",
      "side": 1,
      "message": "optional. note that this sort of test only tests SIMD row functions vs C.  The high level logic is not tested well.\nIts an easy test and useful, but a better test compares a single test function against something that achieves the same result using 2 steps.\nFor example, you could rotate twice vs once.\nOr you could rotate 10 bit and compare to rotate 8 bit, with a conversion from 10 to 8.  This might not work for a subsampled format when the width is odd.\nYou can also do a very simple test with known values and compare against expected results.",
      "revId": "bd46c931f099040c142fc8f2b5597055b2d7ed9d",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}