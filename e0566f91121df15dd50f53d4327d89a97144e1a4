{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "e30777a7_18b5f98f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-02-20T19:08:46Z",
      "side": 1,
      "message": "Overall code looks ok, with minor concerns\n\nIts a large number of public functions and formats.  Do you plan to use them?\nTo avoid technical debt its best to only add functions that apps need, not aim for 100% complete conversions of anything to anything, which would quickly bloat.\nHistorically the goal was new formats require 4 conversions\nXXXXToI420\nI420ToXXXX\nXXXXToARGB\nARGBToXXXX\nIf formats all have this, you can convert from anything to anything in a maximum of 3 steps\nXXXXToI420\nI420ToARGB\nARGBToYYYY\nThe highest complexity is assembly, and this CL does not contain too much assembly, so thats good.\n\nThe header these are in, convert.h, is intended for anything to I420.\nBut these are 10 bit versions, and 2 or 3 planes, so I guess this is the best match for now.\n\nThe function name \u0027DivideRow\u0027 scares me, but it implements with a multiply.  Can\u0027t think of a better name off hand.\n\nSome of the function names are not ideal, but I dont have strong suggestions.\nPx1x for example, internally, doesnt allow for 9 bit.  Which is fine.\nMerge and Split do a shift in a hard coded way.  In future may want unshifted versions.  But we can defer on that until needed.",
      "revId": "e0566f91121df15dd50f53d4327d89a97144e1a4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8cd65399_16da26af",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-02-20T20:08:55Z",
      "side": 1,
      "message": "Performance for P010 etc on SkylakeX (1280x720 1000 iterations)\nP410ToI410_Opt (470 ms)\nI410ToP410_Opt (469 ms)\nP210ToP410_Opt (425 ms)\nP010ToP410_Opt (422 ms)\nP210ToI210_Opt (313 ms)\nI210ToP210_Opt (312 ms)\nI010ToP010_Opt (260 ms)\nP010ToI010_Opt (229 ms)\n\nPixel 4\nP410ToI410_Opt (740 ms)\nP010ToP410_Opt (624 ms)\nP210ToP410_Opt (613 ms)\nI410ToP410_Opt (516 ms)\nP210ToI210_Opt (471 ms)\nP010ToI010_Opt (332 ms)\nI210ToP210_Opt (331 ms)\nI010ToP010_Opt (271 ms)\n",
      "revId": "e0566f91121df15dd50f53d4327d89a97144e1a4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2d185a58_1df9c22a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-02-20T20:34:36Z",
      "side": 1,
      "message": "Tests pass on 32 and 64 bit ARM and 64 bit Intel\nPixel 4 ARM32\nlibyuv_test \u0027--gunit_filter\u003d*Conv*P???*Opt\u0027 --libyuv_width\u003d1280 --libyuv_height\u003d720 --libyuv_repeat\u003d1000 --libyuv_flags\u003d-1 --libyuv_cpu_info\u003d-1\nP016ToP416_Opt (792 ms)\nP010ToP410_Opt (788 ms)\nP012ToP412_Opt (787 ms)\nP412ToI412_Opt (765 ms)\nP410ToI410_Opt (763 ms)\nP210ToP410_Opt (678 ms)\nP212ToP412_Opt (672 ms)\nP216ToP416_Opt (671 ms)\nI410ToP410_Opt (614 ms)\nI412ToP412_Opt (520 ms)\nP210ToI210_Opt (480 ms)\nP212ToI212_Opt (478 ms)\nI212ToP212_Opt (402 ms)\nI210ToP210_Opt (391 ms)\nP012ToI012_Opt (337 ms)\nP010ToI010_Opt (337 ms)\nI010ToP010_Opt (333 ms)\nI012ToP012_Opt (265 ms)\n",
      "revId": "e0566f91121df15dd50f53d4327d89a97144e1a4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "be5142b1_94d38141",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1482051
      },
      "writtenOn": "2021-02-21T04:40:40Z",
      "side": 1,
      "message": "My main goal is to optimize AVIF display, which needs to retain quality. So I need I010ToP010, I210ToP210, I012ToP012, I212ToP212, I010/I210 To I410, I012/I212 To I412, I410 To ARGB/AR30, I412 To ARGB/AR30/AR64, I410Alpha/I412Alpha To ARGB/AR64, and ideally I010/I012/I210/I212 To ARGB/AR30/AR64 with interpolation on chroma internally. I really want to avoid I420 as intermediate format, it has the worst quality both on depth and subsampling.\n\nI\u0027m considering making I010 as the 10bit intermediate format. Content delivered in 10 bit usually looks bad in 8 bit, so users probably won\u0027t use I420 as intermediate format even if it\u0027s there. If one really want, I010\u003c-\u003eI420 is to fill the gap between 8 bit and 10 bit. I210\u003c-\u003eI422 and I410\u003c-\u003eI444 are easy to implement and can avoid scaling, so I added them. \n\nIxxxToPxxx are for direct YUV rendering, PxxxToIxxx are for completeness so that we can say we support Pxxx. P41x can be removed.\n\nWould like to hear your opinion on what to keep.\n\nMaybe we can add a new header dedicated to \u003e8 bit formats.\n\nI believe it\u0027s well known that integer division can be implemented as multiply + right shift for optimization? And it\u0027s the inverse of \u0027MultiplyRow\u0027.\n\nPx1x stands for P410,P210,P010,P412,P212,P012. It\u0027s not likely to have things like P009 so maybe it\u0027s fine?",
      "parentUuid": "e30777a7_18b5f98f",
      "revId": "e0566f91121df15dd50f53d4327d89a97144e1a4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0c584e8d_063e91b6",
        "filename": "include/libyuv/video_common.h",
        "patchSetId": 2
      },
      "lineNbr": 113,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-02-20T19:08:46Z",
      "side": 1,
      "message": "each fourcc also has a BPP define below",
      "range": {
        "startLine": 113,
        "startChar": 0,
        "endLine": 113,
        "endChar": 43
      },
      "revId": "e0566f91121df15dd50f53d4327d89a97144e1a4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "91d5ae83_416a07b2",
        "filename": "include/libyuv/video_common.h",
        "patchSetId": 2
      },
      "lineNbr": 113,
      "author": {
        "id": 1482051
      },
      "writtenOn": "2021-02-21T04:40:40Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "0c584e8d_063e91b6",
      "range": {
        "startLine": 113,
        "startChar": 0,
        "endLine": 113,
        "endChar": 43
      },
      "revId": "e0566f91121df15dd50f53d4327d89a97144e1a4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e3431186_9bfbd899",
        "filename": "source/row_neon64.cc",
        "patchSetId": 2
      },
      "lineNbr": 3551,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-02-20T19:08:46Z",
      "side": 1,
      "message": "nit: align comments",
      "revId": "e0566f91121df15dd50f53d4327d89a97144e1a4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0032464b_6a69af4f",
        "filename": "source/row_neon64.cc",
        "patchSetId": 2
      },
      "lineNbr": 3551,
      "author": {
        "id": 1482051
      },
      "writtenOn": "2021-02-21T04:40:40Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e3431186_9bfbd899",
      "revId": "e0566f91121df15dd50f53d4327d89a97144e1a4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}