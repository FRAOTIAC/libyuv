{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "e30777a7_18b5f98f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-02-20T19:08:46Z",
      "side": 1,
      "message": "Overall code looks ok, with minor concerns\n\nIts a large number of public functions and formats.  Do you plan to use them?\nTo avoid technical debt its best to only add functions that apps need, not aim for 100% complete conversions of anything to anything, which would quickly bloat.\nHistorically the goal was new formats require 4 conversions\nXXXXToI420\nI420ToXXXX\nXXXXToARGB\nARGBToXXXX\nIf formats all have this, you can convert from anything to anything in a maximum of 3 steps\nXXXXToI420\nI420ToARGB\nARGBToYYYY\nThe highest complexity is assembly, and this CL does not contain too much assembly, so thats good.\n\nThe header these are in, convert.h, is intended for anything to I420.\nBut these are 10 bit versions, and 2 or 3 planes, so I guess this is the best match for now.\n\nThe function name \u0027DivideRow\u0027 scares me, but it implements with a multiply.  Can\u0027t think of a better name off hand.\n\nSome of the function names are not ideal, but I dont have strong suggestions.\nPx1x for example, internally, doesnt allow for 9 bit.  Which is fine.\nMerge and Split do a shift in a hard coded way.  In future may want unshifted versions.  But we can defer on that until needed.",
      "revId": "e0566f91121df15dd50f53d4327d89a97144e1a4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8cd65399_16da26af",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-02-20T20:08:55Z",
      "side": 1,
      "message": "Performance for P010 etc on SkylakeX (1280x720 1000 iterations)\nP410ToI410_Opt (470 ms)\nI410ToP410_Opt (469 ms)\nP210ToP410_Opt (425 ms)\nP010ToP410_Opt (422 ms)\nP210ToI210_Opt (313 ms)\nI210ToP210_Opt (312 ms)\nI010ToP010_Opt (260 ms)\nP010ToI010_Opt (229 ms)\n\nPixel 4\nP410ToI410_Opt (740 ms)\nP010ToP410_Opt (624 ms)\nP210ToP410_Opt (613 ms)\nI410ToP410_Opt (516 ms)\nP210ToI210_Opt (471 ms)\nP010ToI010_Opt (332 ms)\nI210ToP210_Opt (331 ms)\nI010ToP010_Opt (271 ms)\n",
      "revId": "e0566f91121df15dd50f53d4327d89a97144e1a4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2d185a58_1df9c22a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-02-20T20:34:36Z",
      "side": 1,
      "message": "Tests pass on 32 and 64 bit ARM and 64 bit Intel\nPixel 4 ARM32\nlibyuv_test \u0027--gunit_filter\u003d*Conv*P???*Opt\u0027 --libyuv_width\u003d1280 --libyuv_height\u003d720 --libyuv_repeat\u003d1000 --libyuv_flags\u003d-1 --libyuv_cpu_info\u003d-1\nP016ToP416_Opt (792 ms)\nP010ToP410_Opt (788 ms)\nP012ToP412_Opt (787 ms)\nP412ToI412_Opt (765 ms)\nP410ToI410_Opt (763 ms)\nP210ToP410_Opt (678 ms)\nP212ToP412_Opt (672 ms)\nP216ToP416_Opt (671 ms)\nI410ToP410_Opt (614 ms)\nI412ToP412_Opt (520 ms)\nP210ToI210_Opt (480 ms)\nP212ToI212_Opt (478 ms)\nI212ToP212_Opt (402 ms)\nI210ToP210_Opt (391 ms)\nP012ToI012_Opt (337 ms)\nP010ToI010_Opt (337 ms)\nI010ToP010_Opt (333 ms)\nI012ToP012_Opt (265 ms)\n",
      "revId": "e0566f91121df15dd50f53d4327d89a97144e1a4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "be5142b1_94d38141",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1482051
      },
      "writtenOn": "2021-02-21T04:40:40Z",
      "side": 1,
      "message": "My main goal is to optimize AVIF display, which needs to retain quality. So I need I010ToP010, I210ToP210, I012ToP012, I212ToP212, I010/I210 To I410, I012/I212 To I412, I410 To ARGB/AR30, I412 To ARGB/AR30/AR64, I410Alpha/I412Alpha To ARGB/AR64, and ideally I010/I012/I210/I212 To ARGB/AR30/AR64 with interpolation on chroma internally. I really want to avoid I420 as intermediate format, it has the worst quality both on depth and subsampling.\n\nI\u0027m considering making I010 as the 10bit intermediate format. Content delivered in 10 bit usually looks bad in 8 bit, so users probably won\u0027t use I420 as intermediate format even if it\u0027s there. If one really want, I010\u003c-\u003eI420 is to fill the gap between 8 bit and 10 bit. I210\u003c-\u003eI422 and I410\u003c-\u003eI444 are easy to implement and can avoid scaling, so I added them. \n\nIxxxToPxxx are for direct YUV rendering, PxxxToIxxx are for completeness so that we can say we support Pxxx. P41x can be removed.\n\nWould like to hear your opinion on what to keep.\n\nMaybe we can add a new header dedicated to \u003e8 bit formats.\n\nI believe it\u0027s well known that integer division can be implemented as multiply + right shift for optimization? And it\u0027s the inverse of \u0027MultiplyRow\u0027.\n\nPx1x stands for P410,P210,P010,P412,P212,P012. It\u0027s not likely to have things like P009 so maybe it\u0027s fine?",
      "parentUuid": "e30777a7_18b5f98f",
      "revId": "e0566f91121df15dd50f53d4327d89a97144e1a4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "69b4467d_f1bfd776",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-02-23T00:38:19Z",
      "side": 1,
      "message": "TLDR  Re completeness\nfunctions live in libyuv for 2 reasons\n1. they can be implemented (in assembly) substantially higher performance than if they are not in libyuv.  Typically an app could implement them in C or with multiple libyuv conversions to work around a missing function.  e.g. theres no RGBScale().  You could convert RGB to ARGB and use libyuv ARGBScale.  or you could write a scale yourself.  Can libyuv implement it more efficiently?  RGB being 3 bytes, thats difficult to say if theres an efficient way to do it for intel, but for ARM yes.  The loads can be ld3().  It would be substantially faster than the alternative.  Its difficult to say if its even possible to do for intel so I\u0027ve deferred.\n\n2. they\u0027re used in production.  If not the function, at least the format. e.g. is P410 used by an app.  What libyuv function will it require?  It may make sense to support additional P410 if it makes testing P410 easier, but in general only functions actually needed by apps are in libyuv.  It reduced technical debt of future support.\nWith the RGBScale example above, the answer is a clear yes, they implement RGB scaling themselves using a 2 step convert and scale.  RGB is increasingly popular for TFLite users.  But mainly on Intel, so its unclear I can do substantially better.  The core function thats needed in AVX2 is an 8x8 transpose. Feel free to write one :-)\n\nRe intermediate\nTo improve color conversion, I\u0027ll be putting emphasis on I444 and I410.\nThose are the 2 yuv formats its important to get the highest quality on, if a tradeoff needs to be made.  I412 is likely important and could be optimized for instead.  I416 would be a more versatile format to aim for so we dont care about msb vs lsb but I expect we\u0027ll use half floats when 16 bits becomes popular.\nNV12 is becoming almost as common as I420 so there will be more conversions to/from NV12.\nI420 with BT.601 limited range is unfortunately a lowest common denominator.\nSo unfortunately everything needs a fallback to this format.\n\nARGB is the common format for rgb.  AR30 is 2:10:10:10 is currently whats supported for 10 bit.\nThere is demand for an fp16 argb format.  fp16 is easy to implement on ARM cpus that have fp16 (Pixel 4 and later).  Its often supported on GPUs.  Its difficult to do efficiently on Intel.\n\nAR64 is likely interesting.  I suggest filing a bug and exploring that with a simple conversion.\nThe yuv conversions, in theory, lend themselves to a \u0027simple\u0027 STOREAR64() macro.  The values are planar - 4 registers, containing 16 bit integer values.  So the conversion to AR64 is relatively high quality and efficient, for a function like I412ToAR64.  There is a half float low level library we could use.",
      "parentUuid": "be5142b1_94d38141",
      "revId": "e0566f91121df15dd50f53d4327d89a97144e1a4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0c584e8d_063e91b6",
        "filename": "include/libyuv/video_common.h",
        "patchSetId": 2
      },
      "lineNbr": 113,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-02-20T19:08:46Z",
      "side": 1,
      "message": "each fourcc also has a BPP define below",
      "range": {
        "startLine": 113,
        "startChar": 0,
        "endLine": 113,
        "endChar": 43
      },
      "revId": "e0566f91121df15dd50f53d4327d89a97144e1a4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "91d5ae83_416a07b2",
        "filename": "include/libyuv/video_common.h",
        "patchSetId": 2
      },
      "lineNbr": 113,
      "author": {
        "id": 1482051
      },
      "writtenOn": "2021-02-21T04:40:40Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "0c584e8d_063e91b6",
      "range": {
        "startLine": 113,
        "startChar": 0,
        "endLine": 113,
        "endChar": 43
      },
      "revId": "e0566f91121df15dd50f53d4327d89a97144e1a4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1de6b83b_f349e9a1",
        "filename": "source/row_gcc.cc",
        "patchSetId": 2
      },
      "lineNbr": 3800,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-02-23T00:38:19Z",
      "side": 1,
      "message": "The value 65536 wont work with unsigned short.  65535 might be close enough?\n65535×65535÷65536 \u003d 65534\nNote In the future I\u0027m thinking, despite this being inline asm, we could use assert for some parameter checks.  eg. assert(scale \u003c 65536)\nThis can also be implemented with a shift, which in my recent tests, is faster than vpmulhuw",
      "revId": "e0566f91121df15dd50f53d4327d89a97144e1a4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e3431186_9bfbd899",
        "filename": "source/row_neon64.cc",
        "patchSetId": 2
      },
      "lineNbr": 3551,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-02-20T19:08:46Z",
      "side": 1,
      "message": "nit: align comments",
      "revId": "e0566f91121df15dd50f53d4327d89a97144e1a4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0032464b_6a69af4f",
        "filename": "source/row_neon64.cc",
        "patchSetId": 2
      },
      "lineNbr": 3551,
      "author": {
        "id": 1482051
      },
      "writtenOn": "2021-02-21T04:40:40Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "e3431186_9bfbd899",
      "revId": "e0566f91121df15dd50f53d4327d89a97144e1a4",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}