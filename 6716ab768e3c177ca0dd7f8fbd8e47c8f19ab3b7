{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "bc65bb5f_bb352a75",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1575067
      },
      "writtenOn": "2023-04-19T07:25:59Z",
      "side": 1,
      "message": "I implement AR/AB64 \u003c-\u003e ARGB conversion with RVV. Can you help to review it?",
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c158fbd7_8847279d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2023-04-19T08:28:06Z",
      "side": 1,
      "message": "Performance is faster for ARGBToAR64?  That takes 4 instructions - load, wadd, mul, store, vs the AR64ToARGB takes 3?  On ARM they are similar\nAR64ToARGB_Opt (499 ms)\nARGBToAR64_Opt (359 ms)",
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "090d612a_17de432a",
        "filename": "source/row_rvv.cc",
        "patchSetId": 1
      },
      "lineNbr": 66,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2023-04-19T07:50:23Z",
      "side": 1,
      "message": "Theres probably a better way to replicate bytes?\n\n1. Is there something like arm\u0027s zip / intel unpack that weaves 2 registers together?\n\n2. Can __riscv_vwmul_vx_u16m2 that can widen the register but still multiply by 0x0101 ?\n\n3. Is there a vsseg trick like replicate the vuint8m1_t registers and treat them as vuint16m2_t for  __riscv_vsseg4e16_v_u16m2?  Thats what I did in ARM, except I just loaded a single register as normal, not vlseg.  copied it and then did vsseg2",
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "20f0abb2_0ebea119",
        "filename": "source/row_rvv.cc",
        "patchSetId": 1
      },
      "lineNbr": 66,
      "author": {
        "id": 1575067
      },
      "writtenOn": "2023-04-19T09:30:19Z",
      "side": 1,
      "message": "1. No 1 vs 1 mapping between them. \n2. The answer is no. If widening from u8 to u16, the input vector or scalar value should be u8. Ref.:https://github.com/riscv/riscv-v-spec/blob/master/v-spec.adoc#1112-vector-widening-integer-multiply-instructions\n3. Based on my understanding to your question 3. \u003d\u003e not really sure misunderstanding or not. \nDo you mean __riscv_vlseg4e8_v_u8m1(b,g,r,a). and directly store with __riscv_vsseg8e8_v_u8m1(r,r,g,g,b,b,a,a)?",
      "parentUuid": "090d612a_17de432a",
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d9feff7f_7256a719",
        "filename": "source/row_rvv.cc",
        "patchSetId": 1
      },
      "lineNbr": 80,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2023-04-19T08:08:59Z",
      "side": 1,
      "message": "could this be more efficient with __riscv_vlseg2e8_v_u8m2 and then __riscv_vsseg1e8_v_u8m1 or whatever a single register store is called?\n\nuse the vlseg2 with bytes to split the low and high bytes of each 16 bit value.  then store just the high 8 bits register",
      "range": {
        "startLine": 80,
        "startChar": 4,
        "endLine": 80,
        "endChar": 29
      },
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8e9e8f7d_a7e97024",
        "filename": "source/row_rvv.cc",
        "patchSetId": 1
      },
      "lineNbr": 80,
      "author": {
        "id": 1575067
      },
      "writtenOn": "2023-04-19T09:30:19Z",
      "side": 1,
      "message": "\u003e could this be more efficient with __riscv_vlseg2e8_v_u8m2 and then __riscv_vsseg1e8_v_u8m1 or whatever a single register store is called?\n\nYou are right.  We don\u0027t need to use segment load here, we can use unit-strided load __riscv_vle16_v here.\n\n\u003e use the vlseg2 with bytes to split the low and high bytes of each 16 bit value. then store just the high 8 bits register\n\nThis is also an good idea for this kernel. I\u0027ll check which is better before providing another cl.",
      "parentUuid": "d9feff7f_7256a719",
      "range": {
        "startLine": 80,
        "startChar": 4,
        "endLine": 80,
        "endChar": 29
      },
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}