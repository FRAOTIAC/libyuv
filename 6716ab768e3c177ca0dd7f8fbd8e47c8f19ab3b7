{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "bc65bb5f_bb352a75",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1575067
      },
      "writtenOn": "2023-04-19T07:25:59Z",
      "side": 1,
      "message": "I implement AR/AB64 \u003c-\u003e ARGB conversion with RVV. Can you help to review it?",
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c158fbd7_8847279d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2023-04-19T08:28:06Z",
      "side": 1,
      "message": "Performance is faster for ARGBToAR64?  That takes 4 instructions - load, wadd, mul, store, vs the AR64ToARGB takes 3?  On ARM they are similar\nAR64ToARGB_Opt (499 ms)\nARGBToAR64_Opt (359 ms)",
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6bd4dbfa_d45bdac7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2023-04-19T09:41:21Z",
      "side": 1,
      "message": "AR64 / AB64 are simple but not commonly used.  So its good practice to implement them, but a more practical gpu friendly 10 bit format is AB30 which is 2:10:10:10\n\nAnother set of useful simple functions are ARGBToABGR etc.  On ARM and Intel I ended up using a common shuffle.  But if vlseg4/vsset4 is more efficient, you can do it that way.",
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e31decd4_fd50f74b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2023-04-19T09:54:26Z",
      "side": 1,
      "message": "The code looks ok and can always be optimized later",
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "11a2db47_6826d7a9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1575067
      },
      "writtenOn": "2023-04-19T12:32:47Z",
      "side": 1,
      "message": "Thank you to remind me. I\u0027ll change it tomorrow.",
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6b722149_1bd46506",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1575067
      },
      "writtenOn": "2023-04-20T09:35:29Z",
      "side": 1,
      "message": "\u003e Another set of useful simple functions are ARGBToABGR\nDarren has been implemented them in the previous. We\u0027ll make CL ASAP.",
      "parentUuid": "6bd4dbfa_d45bdac7",
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b86fdb2d_d7231508",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1575067
      },
      "writtenOn": "2023-04-21T03:23:08Z",
      "side": 1,
      "message": "Actually, we can further optimize AB64 \u003c-\u003e ARGB functions.\nIt will need to use vrgather to swap R \u0026 B.\nWe already used vrgather on ARGB_Shuffle. I think that might have many discussion on implementation with vrgather, so I prefer to keep optimization room here. After we upstream ARGB_Shuffle and have a consensus on vrgather. We can go back to optimize AB64\u003c-\u003eARGB.",
      "parentUuid": "e31decd4_fd50f74b",
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fa2731bb_385d04a0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1573667
      },
      "writtenOn": "2023-04-21T08:17:52Z",
      "side": 1,
      "message": "For those kernels needs tables like vrgather have many to discuss.\nI\u0027ll send a CL for ARGBShuffle and we can discuss it there.\nBut if you have any thoughts about this now,\nI would very much like your opinions first :)\n\nSome of the questions are:\nNot all RISCV targets have the best performance under the same LMUL. \n\u003d\u003e Should we define the code as a MACRO and the LMUL as a variable so that future targets can reuse it? It looks not pretty with the LMUL variables but I can\u0027t think of another solution.\n\nWhat VLEN range do we want to support? \n\u003d\u003e 128, 256, 512,1024, etc.\n\nShould we limit the table size?\n\u003d\u003e For large VLEN and LMUL, the size would be huge here. (e.g. VLEN\u003d1024 + m8, the table would be uint8_t[1024])\n\nThanks",
      "parentUuid": "b86fdb2d_d7231508",
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ddcdb19b_6b77ce56",
        "filename": "source/row_rvv.cc",
        "patchSetId": 1
      },
      "lineNbr": 47,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2023-04-19T09:54:26Z",
      "side": 1,
      "message": "style wise\nsrc_argb +\u003d vl * 4;",
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "63b72b1c_740edd7b",
        "filename": "source/row_rvv.cc",
        "patchSetId": 1
      },
      "lineNbr": 47,
      "author": {
        "id": 1575067
      },
      "writtenOn": "2023-04-19T12:32:47Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "ddcdb19b_6b77ce56",
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6128d35b_8f984805",
        "filename": "source/row_rvv.cc",
        "patchSetId": 1
      },
      "lineNbr": 48,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2023-04-19T09:54:26Z",
      "side": 1,
      "message": "performance wise, consider, vl * 4 could be computed outside the loop\n\nset the initial size outside the loop\nsize_t vl \u003d __riscv_vsetvl_e8m1(avl);\nconst size_t src_stride \u003d vl * 4;\n\ninside the loop, but setvl to bottom of loop\nsrc_argb +\u003d src_stride;\non the last iteration the stride wrong but unused.\nBut if this isnt a win or just too ugly, disreguard.",
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0d18ead1_e023d7e9",
        "filename": "source/row_rvv.cc",
        "patchSetId": 1
      },
      "lineNbr": 48,
      "author": {
        "id": 1573667
      },
      "writtenOn": "2023-04-19T10:39:28Z",
      "side": 1,
      "message": "My understanding is that if there are tail elements then the last two iterations will balance it. Meaning the 2nd one from the end won\u0027t be VLMAX. \n\nDue to the constraints on setting vl: \n1. vl \u003d AVL if AVL ≤ VLMAX\n2. ceil(AVL / 2) ≤ vl ≤ VLMAX if AVL \u003c (2 * VLMAX)\n3. vl \u003d VLMAX if AVL ≥ (2 * VLMAX)\n\nhttps://github.com/riscv/riscv-v-spec/blob/master/v-spec.adoc#63-constraints-on-setting-vl",
      "parentUuid": "6128d35b_8f984805",
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "534d6da6_8161a264",
        "filename": "source/row_rvv.cc",
        "patchSetId": 1
      },
      "lineNbr": 48,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2023-04-19T10:44:21Z",
      "side": 1,
      "message": "Acknowledged.  Thanks for the note.",
      "parentUuid": "0d18ead1_e023d7e9",
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cfb9de52_9a30cdbe",
        "filename": "source/row_rvv.cc",
        "patchSetId": 1
      },
      "lineNbr": 48,
      "author": {
        "id": 1573667
      },
      "writtenOn": "2023-04-19T11:11:28Z",
      "side": 1,
      "message": "Looks like my understanding was not completely correct.\n\nThere\u0027s a NOTE at the end of that section.\n`Requirement 2 also allows an implementation to set vl to VLMAX for VLMAX \u003c AVL \u003c 2*VLMAX`\n\n\nThanks to Bruce point that out.",
      "parentUuid": "534d6da6_8161a264",
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "090d612a_17de432a",
        "filename": "source/row_rvv.cc",
        "patchSetId": 1
      },
      "lineNbr": 66,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2023-04-19T07:50:23Z",
      "side": 1,
      "message": "Theres probably a better way to replicate bytes?\n\n1. Is there something like arm\u0027s zip / intel unpack that weaves 2 registers together?\n\n2. Can __riscv_vwmul_vx_u16m2 that can widen the register but still multiply by 0x0101 ?\n\n3. Is there a vsseg trick like replicate the vuint8m1_t registers and treat them as vuint16m2_t for  __riscv_vsseg4e16_v_u16m2?  Thats what I did in ARM, except I just loaded a single register as normal, not vlseg.  copied it and then did vsseg2",
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "20f0abb2_0ebea119",
        "filename": "source/row_rvv.cc",
        "patchSetId": 1
      },
      "lineNbr": 66,
      "author": {
        "id": 1575067
      },
      "writtenOn": "2023-04-19T09:30:19Z",
      "side": 1,
      "message": "1. No 1 vs 1 mapping between them. \n2. The answer is no. If widening from u8 to u16, the input vector or scalar value should be u8. Ref.:https://github.com/riscv/riscv-v-spec/blob/master/v-spec.adoc#1112-vector-widening-integer-multiply-instructions\n3. Based on my understanding to your question 3. \u003d\u003e not really sure misunderstanding or not. \nDo you mean __riscv_vlseg4e8_v_u8m1(b,g,r,a). and directly store with __riscv_vsseg8e8_v_u8m1(r,r,g,g,b,b,a,a)?",
      "parentUuid": "090d612a_17de432a",
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7872a845_40b00aa7",
        "filename": "source/row_rvv.cc",
        "patchSetId": 1
      },
      "lineNbr": 66,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2023-04-19T09:41:21Z",
      "side": 1,
      "message": "I thought vsseg8 wouldnt exist, but sure.\nBut its probably simplier to do a simple load of 1 register and then vsseg2 with the register specified twice, to replicate it.",
      "parentUuid": "20f0abb2_0ebea119",
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4013f380_a167dbd3",
        "filename": "source/row_rvv.cc",
        "patchSetId": 1
      },
      "lineNbr": 66,
      "author": {
        "id": 1575067
      },
      "writtenOn": "2023-04-19T12:32:47Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "7872a845_40b00aa7",
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "53374aa3_2be37c86",
        "filename": "source/row_rvv.cc",
        "patchSetId": 1
      },
      "lineNbr": 66,
      "author": {
        "id": 1575067
      },
      "writtenOn": "2023-04-20T09:35:29Z",
      "side": 1,
      "message": "If we read with a single vector here, we will get v_argb(b,g,r,a...).\nWe cannot store it with vsseg2 b/c the result will become (b,b,g,g,r,r,a,a...) for AB64, but the expected result is (r,r,g,g,b,b,a,a...).",
      "parentUuid": "4013f380_a167dbd3",
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d9feff7f_7256a719",
        "filename": "source/row_rvv.cc",
        "patchSetId": 1
      },
      "lineNbr": 80,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2023-04-19T08:08:59Z",
      "side": 1,
      "message": "could this be more efficient with __riscv_vlseg2e8_v_u8m2 and then __riscv_vsseg1e8_v_u8m1 or whatever a single register store is called?\n\nuse the vlseg2 with bytes to split the low and high bytes of each 16 bit value.  then store just the high 8 bits register",
      "range": {
        "startLine": 80,
        "startChar": 4,
        "endLine": 80,
        "endChar": 29
      },
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8e9e8f7d_a7e97024",
        "filename": "source/row_rvv.cc",
        "patchSetId": 1
      },
      "lineNbr": 80,
      "author": {
        "id": 1575067
      },
      "writtenOn": "2023-04-19T09:30:19Z",
      "side": 1,
      "message": "\u003e could this be more efficient with __riscv_vlseg2e8_v_u8m2 and then __riscv_vsseg1e8_v_u8m1 or whatever a single register store is called?\n\nYou are right.  We don\u0027t need to use segment load here, we can use unit-strided load __riscv_vle16_v here.\n\n\u003e use the vlseg2 with bytes to split the low and high bytes of each 16 bit value. then store just the high 8 bits register\n\nThis is also an good idea for this kernel. I\u0027ll check which is better before providing another cl.",
      "parentUuid": "d9feff7f_7256a719",
      "range": {
        "startLine": 80,
        "startChar": 4,
        "endLine": 80,
        "endChar": 29
      },
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8ebf2cb0_ab001e32",
        "filename": "source/row_rvv.cc",
        "patchSetId": 1
      },
      "lineNbr": 80,
      "author": {
        "id": 1575067
      },
      "writtenOn": "2023-04-19T09:41:06Z",
      "side": 1,
      "message": "We can also use Vector Strided Load Functions to do it.",
      "parentUuid": "8e9e8f7d_a7e97024",
      "range": {
        "startLine": 80,
        "startChar": 4,
        "endLine": 80,
        "endChar": 29
      },
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d228cbcd_f468b0f0",
        "filename": "source/row_rvv.cc",
        "patchSetId": 1
      },
      "lineNbr": 80,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2023-04-19T09:45:53Z",
      "side": 1,
      "message": "we\u0027re only discarding half the bytes, so a simplier load is probably faster?",
      "parentUuid": "8ebf2cb0_ab001e32",
      "range": {
        "startLine": 80,
        "startChar": 4,
        "endLine": 80,
        "endChar": 29
      },
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e43998a0_727c7ceb",
        "filename": "source/row_rvv.cc",
        "patchSetId": 1
      },
      "lineNbr": 80,
      "author": {
        "id": 1575067
      },
      "writtenOn": "2023-04-19T12:32:47Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "d228cbcd_f468b0f0",
      "range": {
        "startLine": 80,
        "startChar": 4,
        "endLine": 80,
        "endChar": 29
      },
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "345273c0_1cda41b9",
        "filename": "source/row_rvv.cc",
        "patchSetId": 1
      },
      "lineNbr": 80,
      "author": {
        "id": 1575067
      },
      "writtenOn": "2023-04-20T09:35:29Z",
      "side": 1,
      "message": "I rewrite the code with unit-stride load + shift +unit-stride store. The performance improvement is better now.",
      "parentUuid": "e43998a0_727c7ceb",
      "range": {
        "startLine": 80,
        "startChar": 4,
        "endLine": 80,
        "endChar": 29
      },
      "revId": "6716ab768e3c177ca0dd7f8fbd8e47c8f19ab3b7",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}