{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "30e6d843_15f40566",
        "filename": "source/row_sve.cc",
        "patchSetId": 1
      },
      "lineNbr": 58,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2024-04-05T17:47:33Z",
      "side": 1,
      "message": "note that this shift by 6 to convert from 12.6 is a /64 and wanted rounding\n(v+32)/64  but the rounding was added to the bias.  The problem is, bias rounding value only works when the output is expected to be 8 bit.\nIf we support 10 bit, this shift becomes 4, but the rounding should have been adjusted.\nOne solution is change the shifts to rounding shifts, and remove the rounding value from bias.  We did that on risc-v with a hack.\nthe constants are loaded and then 32 is subtracted from the bias.  then the shift is changed to rounding.\nThe downside is intel doesnt have a rounding shift, so it would hurt performance there.",
      "revId": "d12d41817cb72418a56054219c0421aba93e0b7c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "757f02d1_e29a8e30",
        "filename": "source/row_sve.cc",
        "patchSetId": 1
      },
      "lineNbr": 76,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2024-04-05T17:47:33Z",
      "side": 1,
      "message": "note sorry about the clang-formatting.  I think the issue is \u0027volatile\u0027 confuses it, so I\u0027m working on a CL to remove all \u0027volatile\u0027 from existing functions.  \ndeclarations have to be accurate for registers clobbered etc.",
      "revId": "d12d41817cb72418a56054219c0421aba93e0b7c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6cc609df_6a9310a0",
        "filename": "source/row_sve.cc",
        "patchSetId": 1
      },
      "lineNbr": 85,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2024-04-05T17:47:33Z",
      "side": 1,
      "message": "Is it necessary to have this loop that does sub/b.gt in addition to whilelt?  Could the whilelt loop handle both?",
      "revId": "d12d41817cb72418a56054219c0421aba93e0b7c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "985f1a75_3ee194c5",
        "filename": "source/row_sve.cc",
        "patchSetId": 1
      },
      "lineNbr": 95,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2024-04-05T17:47:33Z",
      "side": 1,
      "message": "I have some misgivings about handling remainders in the low levels, as it doubles the size and increases complexity of assembly, and hurts performance in the common case.  libyuv processes camera frames that are virtually guaranteed to be a multiple of 16 pixels wide.  So this code adds branches and cache misses.\nBut avx512/avx10 have masking, which is similar, and riscv does the remainder with the main loop, so this seems to be the way things are going.",
      "revId": "d12d41817cb72418a56054219c0421aba93e0b7c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}