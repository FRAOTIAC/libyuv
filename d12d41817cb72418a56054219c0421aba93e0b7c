{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "dd5e6360_68a46ade",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2024-04-05T18:01:43Z",
      "side": 1,
      "message": "Although I am looking fairly closely at the instructions, reviews for sve will be pretty easy because they only run on a few cpus, so there is unlikely to be a regression... the code just needs to be faster than neon.\n\nI think we can mix and match neon and sve, so initially we should assume sve has 128 bit vectors and the functions that benefit use interesting new instructions.  Which you did here: umulh and interleaving narrow.\n\nThis function I444ToARGB, may be the single most important function in libyuv.\nI420 and NV12 may get used more but when filtering is on, they upsample to I444 first.  And the code is otherwise the same.\nSo if we can think of other improvements, it would be good to do more on I444ToARGB.  i8mm, dotproduct or ssve?",
      "revId": "d12d41817cb72418a56054219c0421aba93e0b7c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "30e6d843_15f40566",
        "filename": "source/row_sve.cc",
        "patchSetId": 1
      },
      "lineNbr": 58,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2024-04-05T17:47:33Z",
      "side": 1,
      "message": "note that this shift by 6 to convert from 12.6 is a /64 and wanted rounding\n(v+32)/64  but the rounding was added to the bias.  The problem is, bias rounding value only works when the output is expected to be 8 bit.\nIf we support 10 bit, this shift becomes 4, but the rounding should have been adjusted.\nOne solution is change the shifts to rounding shifts, and remove the rounding value from bias.  We did that on risc-v with a hack.\nthe constants are loaded and then 32 is subtracted from the bias.  then the shift is changed to rounding.\nThe downside is intel doesnt have a rounding shift, so it would hurt performance there.",
      "revId": "d12d41817cb72418a56054219c0421aba93e0b7c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "757f02d1_e29a8e30",
        "filename": "source/row_sve.cc",
        "patchSetId": 1
      },
      "lineNbr": 76,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2024-04-05T17:47:33Z",
      "side": 1,
      "message": "note sorry about the clang-formatting.  I think the issue is \u0027volatile\u0027 confuses it, so I\u0027m working on a CL to remove all \u0027volatile\u0027 from existing functions.  \ndeclarations have to be accurate for registers clobbered etc.",
      "revId": "d12d41817cb72418a56054219c0421aba93e0b7c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6cc609df_6a9310a0",
        "filename": "source/row_sve.cc",
        "patchSetId": 1
      },
      "lineNbr": 85,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2024-04-05T17:47:33Z",
      "side": 1,
      "message": "Is it necessary to have this loop that does sub/b.gt in addition to whilelt?  Could the whilelt loop handle both?",
      "revId": "d12d41817cb72418a56054219c0421aba93e0b7c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e336124b_035362d6",
        "filename": "source/row_sve.cc",
        "patchSetId": 1
      },
      "lineNbr": 85,
      "author": {
        "id": 1571352
      },
      "writtenOn": "2024-04-08T09:24:00Z",
      "side": 1,
      "message": "The whilelt-based tail could in theory be used as a single loop rather than having a body using ptrue as the predicate for a main loop instead, but this has quite a high penalty on cores like Cortex-A510 (~12% perf hit for this kernel, a lot more when the kernel is a tighter loop).",
      "parentUuid": "6cc609df_6a9310a0",
      "revId": "d12d41817cb72418a56054219c0421aba93e0b7c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "985f1a75_3ee194c5",
        "filename": "source/row_sve.cc",
        "patchSetId": 1
      },
      "lineNbr": 95,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2024-04-05T17:47:33Z",
      "side": 1,
      "message": "I have some misgivings about handling remainders in the low levels, as it doubles the size and increases complexity of assembly, and hurts performance in the common case.  libyuv processes camera frames that are virtually guaranteed to be a multiple of 16 pixels wide.  So this code adds branches and cache misses.\nBut avx512/avx10 have masking, which is similar, and riscv does the remainder with the main loop, so this seems to be the way things are going.",
      "revId": "d12d41817cb72418a56054219c0421aba93e0b7c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "732f42ee_e3fd29cc",
        "filename": "source/row_sve.cc",
        "patchSetId": 1
      },
      "lineNbr": 95,
      "author": {
        "id": 1571352
      },
      "writtenOn": "2024-04-08T09:24:00Z",
      "side": 1,
      "message": "That\u0027s reasonable. It looks okay in this case because most of the logic is hidden away in the macros but for other cases this might be more painful.\n\nEven if we knew that the frames were a multiple of 16 bytes we probably would not be able to easily avoid the predicate setup here unless we restricted these kernels to only work on SVE VL\u003d128-bits, but this might not be the case in future micro-architectures or for Streaming-SVE kernels.\n\nThe predicate calculation here is obviously not free but it should be very cheap (â‰¤ a couple of cycles) compared to the whole loop execution if we are only doing it once. I imagine code size is probably comparable to if we needed an additional \"any\" kernel to handle the remainder?",
      "parentUuid": "985f1a75_3ee194c5",
      "revId": "d12d41817cb72418a56054219c0421aba93e0b7c",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}