{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "bfcd7044_5f575c52",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1208520
      },
      "writtenOn": "2022-12-19T15:13:21Z",
      "side": 1,
      "message": "This initial implementation is based on what is currently being used inside webrtc",
      "revId": "ddefc26639c0ddbc1761508dfd1c8d6e23c6198e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f4552ad3_53717cce",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1208520
      },
      "writtenOn": "2022-12-19T15:14:20Z",
      "side": 1,
      "message": "This initial implementation is based on what is currently being used inside webrtc",
      "revId": "ddefc26639c0ddbc1761508dfd1c8d6e23c6198e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "faa232b4_a765e558",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2022-12-21T02:06:43Z",
      "side": 1,
      "message": "Consider TransposePlane_16() based on TransposePlane() API.  It can be used for Rotate by 90 and 270.",
      "revId": "ddefc26639c0ddbc1761508dfd1c8d6e23c6198e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dbbd73d6_edc7d3bc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2022-12-21T02:11:01Z",
      "side": 1,
      "message": "I think we could simplify this by having a RotatePlane_16 that can be called from I010/I410 etc rotate functions.",
      "revId": "ddefc26639c0ddbc1761508dfd1c8d6e23c6198e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "10bc16fc_b3a93dcc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1208520
      },
      "writtenOn": "2022-12-21T07:50:53Z",
      "side": 1,
      "message": "I have not found any TransposePlane_16 methods in the source code, have I missed anything? where is it?",
      "parentUuid": "faa232b4_a765e558",
      "revId": "ddefc26639c0ddbc1761508dfd1c8d6e23c6198e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1a453703_4eb86c48",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2022-12-21T19:00:44Z",
      "side": 1,
      "message": "Your API etc look good, but this implementation can\u0027t be kept for production.  There are 2 ways to implement this\n1. a row of output can be generated from a column of source using scaling functions.  See ARGBRotate.  Note that UVScale can copy 16 bit values as is.\n2. implement a transpose function.  The transpose implements effeciently on blocks (e.g. 8x8) that can be read, transposed, written.  I\u0027m okay with submitting it if we followup with optimizing it.  See how 8 bit is implemented.",
      "revId": "ddefc26639c0ddbc1761508dfd1c8d6e23c6198e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c67c0b93_1bf889fb",
        "filename": "include/libyuv/version.h",
        "patchSetId": 1
      },
      "lineNbr": 14,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2022-12-21T02:06:43Z",
      "side": 1,
      "message": "When you bump the version here, which is good when there is a new API, also bump the version in the README.chromium in the root.",
      "revId": "ddefc26639c0ddbc1761508dfd1c8d6e23c6198e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3162c34c_1c520ebf",
        "filename": "include/libyuv/version.h",
        "patchSetId": 1
      },
      "lineNbr": 14,
      "author": {
        "id": 1208520
      },
      "writtenOn": "2022-12-21T07:50:53Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c67c0b93_1bf889fb",
      "revId": "ddefc26639c0ddbc1761508dfd1c8d6e23c6198e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "642ff947_18cdabc0",
        "filename": "source/rotate.cc",
        "patchSetId": 1
      },
      "lineNbr": 490,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2022-12-21T02:11:01Z",
      "side": 1,
      "message": "This implements reading a row horizontally, and writing a column.\nIt is more efficient, memory/cache wise, to read a column (bottom to top), and write a row, left to right.\n1. the writes will write combine\n2. the reads will hopefully be cached, so when you read the next column you get some cache hits.",
      "revId": "ddefc26639c0ddbc1761508dfd1c8d6e23c6198e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9400912f_9d985cdd",
        "filename": "source/rotate.cc",
        "patchSetId": 1
      },
      "lineNbr": 490,
      "author": {
        "id": 1208520
      },
      "writtenOn": "2022-12-21T07:50:53Z",
      "side": 1,
      "message": "would it be enough to change the order of the for loops?",
      "parentUuid": "642ff947_18cdabc0",
      "revId": "ddefc26639c0ddbc1761508dfd1c8d6e23c6198e",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}