{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "a6f383f0_74319116",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1482051
      },
      "writtenOn": "2021-01-29T12:18:44Z",
      "side": 1,
      "message": "I\u0027m not very familiar with NEON, so I only implemented x86 SIMD.\n\nThe core logic can be ported to work on 10bit and 12bit easily, so I added them. But it\u0027s not suitable for 16bit. (Intermediate value can reach 16*maxValue, so 12bit is the limit)\n\nCurrently there\u0027s only row functions and API functions work on plane. Should we change the current I420ToARGB function or have another function like I420ToARGBBilinear?",
      "revId": "f429ff6236b1b5ddf846264fd8bdf22da8e9f6e8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0c65d5f0_8391bfb0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-01-29T18:32:03Z",
      "side": 1,
      "message": "These seem like they should be exposed publically a conversions, not scaling.\n\nConversions allow odd width destination, which you may want to handle via \u0027row_any\u0027 wrappers.\n\ne.g. I420ToI444 of an odd width image 639x480 should filter the UV similar to 640x480 but handle the last pixel with clamping.  One way to implement edge clamping is copy the row to a buffer and extrude the first and last pixel out, allowing the low level to process 2 pixels at a time.\n\nThe next level lower can be implemented as planar scaling, and ensure the low levels have specialized upsampling of 2x vertically and/or horizontally.\n\nLinear support is low priority - it can be implemented as Bilinear with a row stride of 0, and will still be a performance win.  I\u0027m tempted to remove linear row functions, but chroma upsampling is one usecase where it may still make sense.  I422ToI444 where the height is already full height, just needs horizontal upsample.\n\nAlso note there is uv_scale functions for NV12 scaling.  Many applications are moving toward NV12 instead of planar, and it has scaling performance advantages.\nWe\u0027ll need optimized filtering and 16 bit UV channels.\nUV scale is based on ARGB scale, and I anticipate RGB scale, and rotate for UV and RGB, with all row functions implemented in SIMD.\nThe API, both publically and low level row functions, needs to stay low to be feasible / maintainable / optimizable. ",
      "revId": "f429ff6236b1b5ddf846264fd8bdf22da8e9f6e8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "aa918ff9_ffdc939c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-01-29T23:53:35Z",
      "side": 1,
      "message": "I420ToI444 uses:\n\nScalePlane(src_v, src_stride_v, src_uv_width, src_uv_height, dst_v,\n           dst_stride_v, dst_uv_width, dst_uv_height, kFilterBilinear);\n\ninternally ScalePlane should be checking for 2x upsampling and using a specialized row function if its substantially faster.\n\nIts okay to have I420ToI444 directly call the row functions.",
      "revId": "f429ff6236b1b5ddf846264fd8bdf22da8e9f6e8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ff3727f8_80edf9c7",
        "filename": "include/libyuv/scale.h",
        "patchSetId": 2
      },
      "lineNbr": 172,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-01-29T18:32:03Z",
      "side": 1,
      "message": "api issues\n-public functions take enum FilterMode filtering to support bilinear vs linear.\n-public api change should not be necessary?  make sure low level ScalePlane with dest width \u003d source width * 2 works as expected for a specialized low level function.\n-function names are misleading, as they dont accept I420/I444.\nOne way to achieve a 2 plane scale would be pass null for Y.\nAnother way to expose the functionality is via convert API.  I420ToI444()",
      "revId": "f429ff6236b1b5ddf846264fd8bdf22da8e9f6e8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9ed95eed_50fb1b5a",
        "filename": "include/libyuv/scale.h",
        "patchSetId": 2
      },
      "lineNbr": 172,
      "author": {
        "id": 1482051
      },
      "writtenOn": "2021-01-30T02:51:06Z",
      "side": 1,
      "message": "ScalePlane can dispatch to the specialized version. I may move these into convert API.",
      "parentUuid": "ff3727f8_80edf9c7",
      "revId": "f429ff6236b1b5ddf846264fd8bdf22da8e9f6e8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "68f00c9d_4215d16a",
        "filename": "include/libyuv/scale.h",
        "patchSetId": 2
      },
      "lineNbr": 201,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-01-29T18:32:03Z",
      "side": 1,
      "message": "For now I plan to support _16() versions of planar functions.  The 9, 10, 12, and 16 bit variants aren\u0027t exposed.  If values go out of range a conversion will need to clamp them.\ne.g. I012ToI010 and/or I010ToI420 would clamp.",
      "revId": "f429ff6236b1b5ddf846264fd8bdf22da8e9f6e8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "316e170c_a19a2d8a",
        "filename": "include/libyuv/scale.h",
        "patchSetId": 2
      },
      "lineNbr": 201,
      "author": {
        "id": 1482051
      },
      "writtenOn": "2021-01-30T02:51:06Z",
      "side": 1,
      "message": "These _16 row functions produce result in the same bitdepth of src so they are for I010ToI410(yuv420p10 to yuv444p10) and I012ToI412(yuv420p12 to yuv444p12) (Did I use the correct four cc?). But these functions interpolate lower 12bits so they are only suitable for \u003c\u003d 12bit. Interpolating higher 12bits is also possible, but very inaccurate for 10/12bit input.",
      "parentUuid": "68f00c9d_4215d16a",
      "revId": "f429ff6236b1b5ddf846264fd8bdf22da8e9f6e8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "561ffb41_16271fd1",
        "filename": "include/libyuv/scale_row.h",
        "patchSetId": 2
      },
      "lineNbr": 80,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-01-29T18:32:03Z",
      "side": 1,
      "message": "Seems like more row functions than necessary.\nAll row functions should be implemented in assembly for Neon and AVX2.\n\nARM has 1 function for 16 bit channel upsample\nScaleRowUp2_16_NEON",
      "revId": "f429ff6236b1b5ddf846264fd8bdf22da8e9f6e8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "349d7682_4753fc32",
        "filename": "include/libyuv/scale_row.h",
        "patchSetId": 2
      },
      "lineNbr": 80,
      "author": {
        "id": 1482051
      },
      "writtenOn": "2021-01-30T02:51:06Z",
      "side": 1,
      "message": "Half of them are just wrapped ones, like the Any_ ones. See below for explanation. I agree the names may need some change. \n\nI\u0027ll try do write the neon version.",
      "parentUuid": "561ffb41_16271fd1",
      "revId": "f429ff6236b1b5ddf846264fd8bdf22da8e9f6e8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1ea0dbad_28aa868f",
        "filename": "include/libyuv/scale_row.h",
        "patchSetId": 2
      },
      "lineNbr": 283,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-01-29T18:32:03Z",
      "side": 1,
      "message": "Names are inconsistent with existing row functions.  RowHorizontal \u003d Col?\nCore_ ?   Remove from name?\nRow functions are broken into their own functions because they get CPU dispatched and are simple APIs.\nI havent looked at implementation but I expect non-core dont need to be row functions?",
      "revId": "f429ff6236b1b5ddf846264fd8bdf22da8e9f6e8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "049201b6_95623f1f",
        "filename": "include/libyuv/scale_row.h",
        "patchSetId": 2
      },
      "lineNbr": 283,
      "author": {
        "id": 1482051
      },
      "writtenOn": "2021-01-30T02:51:06Z",
      "side": 1,
      "message": "I see. I\u0027ll change to Col.\n\nThese assumes src pixels are placed at center of dst pixels, so boundary pixels need to be handled differently. Core_ ones don\u0027t do this, a macro wraps Core_ ones to take care of boundary pixels. Naming warpped functions Any_ might be misleading because Core_ ones should never be called directly even if src is aligned.",
      "parentUuid": "1ea0dbad_28aa868f",
      "revId": "f429ff6236b1b5ddf846264fd8bdf22da8e9f6e8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e23937e4_c1d31583",
        "filename": "source/scale.cc",
        "patchSetId": 2
      },
      "lineNbr": 1343,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-01-29T18:32:03Z",
      "side": 1,
      "message": "linear can be implemented as bilinear with stride of 0",
      "revId": "f429ff6236b1b5ddf846264fd8bdf22da8e9f6e8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d5f10efc_22b8a65f",
        "filename": "source/scale.cc",
        "patchSetId": 2
      },
      "lineNbr": 1343,
      "author": {
        "id": 1482051
      },
      "writtenOn": "2021-01-30T02:51:06Z",
      "side": 1,
      "message": "Bilinear version reads 2 rows and writes 2 rows for each call. Compared with read 2 and write 1, this reduce 40% execution time.\nUsing bilinear to mimic linear doubles execution time. Currently with same output size, time on I422ToI444 and I420ToI444 are roughly the same.",
      "parentUuid": "e23937e4_c1d31583",
      "revId": "f429ff6236b1b5ddf846264fd8bdf22da8e9f6e8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c305f899_0ecdded7",
        "filename": "source/scale.cc",
        "patchSetId": 2
      },
      "lineNbr": 1391,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-01-29T18:32:03Z",
      "side": 1,
      "message": "conversions and scale allow height \u003c 0 to invert vertically.\nmay want to allow horizontal flip if using a scaling kernel by stepping through source pixels with -1 pixel stride.\nFYI I may move to \u0027check macro\u0027 in future to allow an optimized build to have asserts.\nnon-debug functions typically return.\nthis function is public?   would need LIBYUV to export the symbol.",
      "range": {
        "startLine": 1391,
        "startChar": 0,
        "endLine": 1391,
        "endChar": 42
      },
      "revId": "f429ff6236b1b5ddf846264fd8bdf22da8e9f6e8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9e08331c_1ba04e24",
        "filename": "source/scale.cc",
        "patchSetId": 2
      },
      "lineNbr": 1391,
      "author": {
        "id": 1482051
      },
      "writtenOn": "2021-01-30T02:51:06Z",
      "side": 1,
      "message": "Invert vertically is easy.\nHorizontal flip may need to duplicate assembly.\nThis is private. ScalePlane will dispatch this function if condition is met. ScaleI420ToI444 also call this internally.",
      "parentUuid": "c305f899_0ecdded7",
      "range": {
        "startLine": 1391,
        "startChar": 0,
        "endLine": 1391,
        "endChar": 42
      },
      "revId": "f429ff6236b1b5ddf846264fd8bdf22da8e9f6e8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b8a79c80_cca4e1ed",
        "filename": "source/scale.cc",
        "patchSetId": 2
      },
      "lineNbr": 1407,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-01-29T18:32:03Z",
      "side": 1,
      "message": "no necessary - use stride of 0",
      "revId": "f429ff6236b1b5ddf846264fd8bdf22da8e9f6e8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7033afd6_7ecfac59",
        "filename": "source/scale.cc",
        "patchSetId": 2
      },
      "lineNbr": 1407,
      "author": {
        "id": 1482051
      },
      "writtenOn": "2021-01-30T02:51:06Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "b8a79c80_cca4e1ed",
      "revId": "f429ff6236b1b5ddf846264fd8bdf22da8e9f6e8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eab1c358_489abbc2",
        "filename": "source/scale_gcc.cc",
        "patchSetId": 2
      },
      "lineNbr": 791,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-01-29T23:53:35Z",
      "side": 1,
      "message": "these constants could be generated.  worst case I\u0027ve seen, loading a simd constant from memory is 100 cycles in 32 bit, due to fpic.  if you can generate a constant in 3 instructions its a speed advantage.\n32 bit is becoming lower priority though.  make sure it builds and achieves the same performance as 64 bit if possible.",
      "revId": "f429ff6236b1b5ddf846264fd8bdf22da8e9f6e8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a8748f96_1cbc25a1",
        "filename": "source/scale_gcc.cc",
        "patchSetId": 2
      },
      "lineNbr": 791,
      "author": {
        "id": 1482051
      },
      "writtenOn": "2021-01-30T02:51:06Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "eab1c358_489abbc2",
      "revId": "f429ff6236b1b5ddf846264fd8bdf22da8e9f6e8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "380c24db_8a64629f",
        "filename": "source/scale_gcc.cc",
        "patchSetId": 2
      },
      "lineNbr": 793,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-01-29T23:53:35Z",
      "side": 1,
      "message": "the functions in this file are what we should have C row functions for.  Anything else can be internal to the higher level.  Try to reduce the number of functions that need to be ported / optimized.  We\u0027ll want ssse3, avx512, neon 32 and 64 bit, and mips msa.  And they may need to be ported to other compilers, like visual c.\nIf theres not a larger performance improvement, consider removing linear and use bilinear to implement it with the source row pointer duplicated.",
      "range": {
        "startLine": 793,
        "startChar": 0,
        "endLine": 793,
        "endChar": 67
      },
      "revId": "f429ff6236b1b5ddf846264fd8bdf22da8e9f6e8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "042c7219_eb9c4dcd",
        "filename": "source/scale_gcc.cc",
        "patchSetId": 2
      },
      "lineNbr": 793,
      "author": {
        "id": 1482051
      },
      "writtenOn": "2021-01-30T02:51:06Z",
      "side": 1,
      "message": "Explained above. non-Core_ versions are just wrappers around Core_ versions, just like Any_ versions are. If you think naming the wrapped version Any_ and removing Core_ in names is appropriate I\u0027ll switch to that.\n\nHalf the time should be a large enough performance improvement, right?",
      "parentUuid": "380c24db_8a64629f",
      "range": {
        "startLine": 793,
        "startChar": 0,
        "endLine": 793,
        "endChar": 67
      },
      "revId": "f429ff6236b1b5ddf846264fd8bdf22da8e9f6e8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5a2ab829_28dba69f",
        "filename": "source/scale_gcc.cc",
        "patchSetId": 2
      },
      "lineNbr": 1175,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-01-29T23:53:35Z",
      "side": 1,
      "message": "consider vpmaddubsw which will let you multiply by coefficients, add adjacient values, produces 16 bit.\nafter unpacks it should be 2 vpmaddubsw, add the 2 rows, add a rounding value and shift.\narm could be similar but theres a rounding shift, avoiding the add for rounding, and the multiply has an accumulate.",
      "range": {
        "startLine": 1175,
        "startChar": 0,
        "endLine": 1175,
        "endChar": 59
      },
      "revId": "f429ff6236b1b5ddf846264fd8bdf22da8e9f6e8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9d098be4_7e65117e",
        "filename": "source/scale_gcc.cc",
        "patchSetId": 2
      },
      "lineNbr": 1175,
      "author": {
        "id": 1482051
      },
      "writtenOn": "2021-01-30T02:51:06Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "5a2ab829_28dba69f",
      "range": {
        "startLine": 1175,
        "startChar": 0,
        "endLine": 1175,
        "endChar": 59
      },
      "revId": "f429ff6236b1b5ddf846264fd8bdf22da8e9f6e8",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}