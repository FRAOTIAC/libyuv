{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "43a5cc9b_b5cc1167",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2024-02-29T21:38:35Z",
      "side": 1,
      "message": "thanks for the fix.\nI wouldnt have noticed this, as I watch issues.\nhttps://bugs.chromium.org/p/libyuv/issues/list\nIts good to file a bug and refer to it in a change",
      "revId": "d13b64a3d84ccf78dcd0a9e160203aa1625c7351",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2c8b2af0_7c2d8945",
        "filename": "source/scale_neon64.cc",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2024-02-29T21:38:35Z",
      "side": 1,
      "message": "prefer \"memory\" and \"cc\" be first in the clobber list.",
      "revId": "d13b64a3d84ccf78dcd0a9e160203aa1625c7351",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "023dbe24_7dff43c5",
        "filename": "source/scale_neon64.cc",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2024-03-03T21:29:59Z",
      "side": 1,
      "message": "It is also done the wrong in row_neon.cc as well.\n\nI\u0027m doing a change for all inline to remove the \u0027volatile\u0027 keyword, and it will be important to declare input/output/clobber correctly.\nIts already important with link time pgolite, where the volatile is ignored and instructions can be removed/reordered.  It is not enough to comply with the ABI.",
      "parentUuid": "2c8b2af0_7c2d8945",
      "revId": "d13b64a3d84ccf78dcd0a9e160203aa1625c7351",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0b4c7159_f6090f0e",
        "filename": "source/scale_neon64.cc",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 1571352
      },
      "writtenOn": "2024-03-04T09:43:24Z",
      "side": 1,
      "message": "Fixed up the ones in scale_neon64.cc.\n\nI have a few changes locally to move some initial row_neon64.cc kernels across to mostly intrinsics (with a couple of fallbacks to inline-asm where the compiler currently does a poor job) which are showing good speedups. I\u0027ll raise a bug ticket to track that at some point in the next few days.\n\nFor the kernels that we can\u0027t currently move across to intrinsics, we could be a lot more specific about what memory is being accessed by moving the loop control out of the inline asm and using memory asm constraints (e.g. \"m\" rather than \"r\" etc).\n\nWhat do you think about this?",
      "parentUuid": "023dbe24_7dff43c5",
      "revId": "d13b64a3d84ccf78dcd0a9e160203aa1625c7351",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "47466317_fac3ed5c",
        "filename": "source/scale_neon64.cc",
        "patchSetId": 1
      },
      "lineNbr": 41,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2024-03-04T10:08:35Z",
      "side": 1,
      "message": "prefer assembly for performance and fewer bugs.\ne.g. ld1 dup has a bug in clang 16 for arm32\nif intrinsics are necessary for another platform/compiler, an additional file could be added, similar to row_win.cc for visual studio.\n\nre for loops\nI\u0027m seeing issues with do while loops in clang 17 causing register spill with intrinsics.\ntypical for loops use an extra register or compare.  In the inline assembly there is no compare except the loop subs.  Remainders are handled by \u0027row_any\u0027 functions.\n\nre \"m\"\nregisters are used for loop counts and pointers which require registers on arm.\n\nAs libyuv doesnt have different versions for each cpu, cortex a53 benchmarks are mainly used to determine best performance.\nBut a blended performance across all cortex and exynos cpus are considered.\nThe 32 bit neon performance should normally match 64 bit.",
      "parentUuid": "0b4c7159_f6090f0e",
      "revId": "d13b64a3d84ccf78dcd0a9e160203aa1625c7351",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}