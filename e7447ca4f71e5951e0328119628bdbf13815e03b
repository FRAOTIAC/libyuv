{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "24e74c4b_8dc3a991",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-03-05T02:48:02Z",
      "side": 1,
      "message": "perfect!  thanks.  I have a script for applying clang tidy --fix so no worries.\nThe plan is to switch win32 builds to row_gcc.cc clangcl the same as win64.\nAnd then remove the visual c specific assembly, but perhaps keep intrinsics around for actual visual cl, as long as theres a way to test it.\nI\u0027m hoping windows arm builds can also do the same.\nFor now, keep it working until theres a good reason to break it.",
      "revId": "e7447ca4f71e5951e0328119628bdbf13815e03b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fb7084c8_76b32687",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-03-05T02:51:58Z",
      "side": 1,
      "message": "if you can think of any tricks for making the assembly actually work for 32 bit, that would be good.\nIt would build if fpic were turned off, and fpic is not relevant to code that has no global memory variables.\nfor functions that are almost out of GPR registers I start by making the loop counter a \"m\" parameter (stack).",
      "revId": "e7447ca4f71e5951e0328119628bdbf13815e03b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a3da3e30_8f25c4d6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1482051
      },
      "writtenOn": "2021-03-05T07:29:11Z",
      "side": 1,
      "message": "Is there any reason we can\u0027t use C style intrinsic functions? That would simplify many things.",
      "parentUuid": "24e74c4b_8dc3a991",
      "revId": "e7447ca4f71e5951e0328119628bdbf13815e03b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e614dd42_6ab8bab2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-03-10T03:10:54Z",
      "side": 1,
      "message": "intrinsics tend to under perform.  they have simd math, but not load/stores and dont give you as much control over scheduling. The compilers dont do register allocation as well as they should, especially affecting 32 bit performance. I typically gain 10-20% performance using assembly compared to intrinsics.",
      "parentUuid": "a3da3e30_8f25c4d6",
      "revId": "e7447ca4f71e5951e0328119628bdbf13815e03b",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}