{
  "comments": [
    {
      "key": {
        "uuid": "046ca284_5f4493f5",
        "filename": "source/cpu_id.cc",
        "patchSetId": 1
      },
      "lineNbr": 250,
      "author": {
        "id": 1221903
      },
      "writtenOn": "2020-02-25T13:33:45Z",
      "side": 1,
      "message": "changes here wil invalidate the runtime check.\nprevious: msa/mmi can be enabled only when both build and runtime checks passed.\nnow: msa/mmi will be enabled  if any one of build and runtime checks passed.",
      "range": {
        "startLine": 242,
        "startChar": 0,
        "endLine": 250,
        "endChar": 6
      },
      "revId": "ffc97b524598b13581054a902ef9d1a54311ad32",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fcb197e3_81384f7d",
        "filename": "source/cpu_id.cc",
        "patchSetId": 1
      },
      "lineNbr": 250,
      "author": {
        "id": 1314732
      },
      "writtenOn": "2020-02-25T13:43:52Z",
      "side": 1,
      "message": "That\u0027s expected behavior.\ncpu_id.cc is compiled with the baseline cflag, if the baseline indicated it support MSA/MMI, then we don\u0027t have to doubt it.\n\nThat\u0027s why in lines below, #if defined(__ARM_NEON__) will mark cpu_info \u003d kCpuHasNEON.",
      "parentUuid": "046ca284_5f4493f5",
      "range": {
        "startLine": 242,
        "startChar": 0,
        "endLine": 250,
        "endChar": 6
      },
      "revId": "ffc97b524598b13581054a902ef9d1a54311ad32",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "40cb90ea_958de382",
        "filename": "source/cpu_id.cc",
        "patchSetId": 1
      },
      "lineNbr": 250,
      "author": {
        "id": 1221903
      },
      "writtenOn": "2020-02-25T14:06:46Z",
      "side": 1,
      "message": "\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n[yinsy@localhost ~]$ gcc -dM -E - \u003c/dev/null | grep msa\n[yinsy@localhost ~]$ gcc -mmsa -dM -E - \u003c/dev/null | grep msa\n#define __mips_msa 1\n#define __mips_msa_width 128\n[yinsy@localhost ~]$ cat /proc/cpuinfo | grep \"ASEs implemented\"\nASEs implemented\t: vz msa\nASEs implemented\t: vz msa\nASEs implemented\t: vz msa\nASEs implemented\t: vz msa\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nIf baseline cflags has no -mmsa, the previous code will not to check cpuinfo, but now it will. For reference only, I havn\u0027t tested yet.",
      "parentUuid": "fcb197e3_81384f7d",
      "range": {
        "startLine": 242,
        "startChar": 0,
        "endLine": 250,
        "endChar": 6
      },
      "revId": "ffc97b524598b13581054a902ef9d1a54311ad32",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "665d3add_1e3ee54a",
        "filename": "source/cpu_id.cc",
        "patchSetId": 1
      },
      "lineNbr": 250,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2020-02-28T01:05:09Z",
      "side": 1,
      "message": "Caveat if you compile with -mmsa this enables MSA for all code as a requirement and you should expect a failure of the code is run on a device without MSA.\nOn Neon this was done mostly for the benefit of chromium sandbox, which prevents reading the file /proc/cpuinfo.  Since neon is available on all modern devices, it is enabled by default with the compile flag.\nIf libyuv is compiled without neon, it can still attempt to detect neon via /proc/cpuinfo.\nOn Intel the cpuid can be read without sandbox restrictions.\nIt would be better in the future to find a sandbox friendly way to detect cpu instruction extensions.",
      "parentUuid": "40cb90ea_958de382",
      "range": {
        "startLine": 242,
        "startChar": 0,
        "endLine": 250,
        "endChar": 6
      },
      "revId": "ffc97b524598b13581054a902ef9d1a54311ad32",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba",
      "unresolved": true
    }
  ]
}