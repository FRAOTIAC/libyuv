{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "4ad5f5b7_55840e2c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1482051
      },
      "writtenOn": "2021-04-13T16:25:03Z",
      "side": 1,
      "message": "Use UMLAL to calc UV contribution to G. All functions are at least not slower:\n\nARMv7:\n[       OK ] LibYUVConvertTest.I420ToARGB_Opt (957 ms)\n[       OK ] LibYUVConvertTest.I422ToARGB_Opt (931 ms)\n[       OK ] LibYUVConvertTest.I444ToARGB_Opt (779 ms)\n[       OK ] LibYUVConvertTest.I420AlphaToARGB_Opt (997 ms)\n[       OK ] LibYUVConvertTest.I422AlphaToARGB_Opt (969 ms)\n[       OK ] LibYUVConvertTest.I444AlphaToARGB_Opt (786 ms)\n[       OK ] LibYUVConvertTest.NV12ToARGB_Opt (815 ms)\n[       OK ] LibYUVConvertTest.NV21ToARGB_Opt (828 ms)\n[       OK ] LibYUVConvertTest.I400ToARGB_Opt (752 ms)\n[       OK ] LibYUVConvertTest.UYVYToARGB_Opt (865 ms)\n[       OK ] LibYUVConvertTest.YUY2ToARGB_Opt (847 ms)\n\nARMv8:\n[       OK ] LibYUVConvertTest.I420ToARGB_Opt (783 ms)\n[       OK ] LibYUVConvertTest.I422ToARGB_Opt (778 ms)\n[       OK ] LibYUVConvertTest.I444ToARGB_Opt (736 ms)\n[       OK ] LibYUVConvertTest.I420AlphaToARGB_Opt (787 ms)\n[       OK ] LibYUVConvertTest.I422AlphaToARGB_Opt (787 ms)\n[       OK ] LibYUVConvertTest.I444AlphaToARGB_Opt (754 ms)\n[       OK ] LibYUVConvertTest.NV12ToARGB_Opt (679 ms)\n[       OK ] LibYUVConvertTest.NV21ToARGB_Opt (679 ms)\n[       OK ] LibYUVConvertTest.I400ToARGB_Opt (714 ms)\n[       OK ] LibYUVConvertTest.UYVYToARGB_Opt (801 ms)\n[       OK ] LibYUVConvertTest.YUY2ToARGB_Opt (738 ms)\n\nUsing UMLAL on UV contribution to R/B is slower, due to additional data dependency.",
      "revId": "d0b91d9aaf012c36abf3d388d1257dc54780be77",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "17ff594f_67148dc3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-04-13T19:16:16Z",
      "side": 1,
      "message": "Your Neon is getting very good!  Tested on Cortex A53, which is the little core on many CPUs and one of the most sensitive to performance:\n\nWas:\nI420ToARGB_Opt (2321 ms)\nI422ToARGB_Opt (2372 ms)\nI444ToARGB_Opt (2707 ms)\nI420AlphaToARGB_Opt (2556 ms)\nI422AlphaToARGB_Opt (2598 ms)\nI444AlphaToARGB_Opt (2961 ms)\nNV12ToARGB_Opt (2463 ms)\nNV21ToARGB_Opt (2459 ms)\nI400ToARGB_Opt (2177 ms)\nUYVYToARGB_Opt (2417 ms)\nYUY2ToARGB_Opt (2414 ms)\n\nNow:\nI420ToARGB_Opt (1779 ms)\nI422ToARGB_Opt (1883 ms)\nI444ToARGB_Opt (2030 ms)\nI420AlphaToARGB_Opt (2025 ms)\nI422AlphaToARGB_Opt (2111 ms)\nI444AlphaToARGB_Opt (2279 ms)\nNV12ToARGB_Opt (1705 ms)\nNV21ToARGB_Opt (1713 ms)\nI400ToARGB_Opt (1589 ms)\nUYVYToARGB_Opt (1818 ms)\nYUY2ToARGB_Opt (1816 ms)\n\n32 bit Now\nI420ToARGB_Opt (2087 ms)\nI422ToARGB_Opt (2291 ms)\nI444ToARGB_Opt (2681 ms)\nI420AlphaToARGB_Opt (2766 ms)\nI422AlphaToARGB_Opt (2897 ms)\nI444AlphaToARGB_Opt (3463 ms)\nNV12ToARGB_Opt (1967 ms)\nNV21ToARGB_Opt (1973 ms)\nI400ToARGB_Opt (1721 ms)\nUYVYToARGB_Opt (2039 ms)\nYUY2ToARGB_Opt (2069 ms)\n\n3 things to consider (for future)\n-instead of full vectors for constants, a single vector could be used for all multiply constants, using \u0027elements\u0027 to select which constant.\n-mla also has mls variant that does subtract.  unfortunately both arm and intel only do 3 parameters, so the destination is the accumulator and requires a mov to initialize it, so likely not a win here.\n-udot instruction multiplies 4 bytes (e.g. ayuv) by 4 values (coefficients) and adds them together to make a uint32_t.  It produces 4 uint32_t at a time.  Its ideal for argb to yuv, but unclear it can be used on yuv to rgb, due to differing signs on r,b and g.\n\nIn the future, constants structure should be used for RGB to YUV as well.",
      "revId": "d0b91d9aaf012c36abf3d388d1257dc54780be77",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "973e901b_14e8332f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1482051
      },
      "writtenOn": "2021-04-14T01:32:28Z",
      "side": 1,
      "message": "UMLAL/UMULL by element only supports U16 or U32, and want the element in low register (d0-d7 on armv7, v0-v15 on armv8).\n\nMLA and MLS do not saturate. This is the bigger problem.",
      "parentUuid": "17ff594f_67148dc3",
      "revId": "d0b91d9aaf012c36abf3d388d1257dc54780be77",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c53ff9f9_d2cf7902",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1482051
      },
      "writtenOn": "2021-04-14T03:42:53Z",
      "side": 1,
      "message": "Analysis\n\nThis is the C code we are going to optimize:\n\n    y1 \u003d (uint32_t)(y * 0x0101 * yg) \u003e\u003e 16;\n    b \u003d (int)(y1 + (u * ub) + bb);\n    g \u003d (int)(y1 + (u * ug + v * vg) + bg);\n    r \u003d (int)(y1 + (v * vr) + br);\n\nTo use unsigned arithmetic, we need to first figure out sign and range for each term.\n\n- Range of yg and y1:\nyg is always 16320 for full range YUV. For limited range YUV, it\u0027s round(A * 64 * 256 * 256 / 257), where A is the scale from limited range to full range. A depends on input bit depth, for N bit input, A \u003d ((1 \u003c\u003c N) - 1) / (219 \u003c\u003c (N - 8)). So the value varies between 19003 (N \u003d 8, A \u003d 255/219) and 19078 (N -\u003e inf, A \u003d 256/219). \ny is always positive and maximum is 255, so 0 \u003c\u003d y1 \u003c\u003d 19077 ((255 * 0x101 * 19078) \u003e\u003e 16). It\u0027s safe to store it in U16.\n\n- Range of ub, vr, u * ub and v * vr:\nub is u\u0027s contribution to b. u \u003d (b - y) / (2 * (1 - kb)), so ub is bigger when b contributes less to y. The extreme case is XYZ colorspace, where b doesn\u0027t contribute to y at all. In this case, with limited range, ubf \u003d ((1 \u003c\u003c N) - 1) / (112 \u003c\u003c (N - 8)) and ub \u003d round(ubf * 64), so ub \u003c\u003d 146. The same applies to vr.\nu is always positive and maximum is 255, so 0 \u003c\u003d u * ub \u003c\u003d 37230. The same applies to v * vr. It\u0027s safe to store it in U16.\n\n- Range of ug, vg, u * ug + v * vg:\nug and vg are u and v\u0027s contribution to g. These are usually small, and even smaller for wider gamut. For a reasonable colorspace Green contributes most in y. The extreme case is kr \u003d kb \u003d 1/3, with limited range, ugf \u003d 2 * (kb - 1) * kb / (1 - kb - kr) * ((1 \u003c\u003c N) - 1) / (112 \u003c\u003c (N - 8)) and ug \u003d round(ugf * 64), so ug \u003e\u003d -98. The same applies to vg.\nu and v are always positive and maximum is 255, so -49980 \u003c\u003d u * ug + v * vg \u003c\u003d 0. It\u0027s safe to store its negative in U16.\n\n- Range of bb, bg and br:\nBias consists of 3 parts: \n 1. u and v are stored as actual value + 128, so ub * 128 and alike should be subtracted.\n 2. In limited range y are stored with bias A * 64 * -16.\n 3. Rounding bias, which is always 32.\n\nWe know ub \u003c\u003d 146, so ub * 128 \u003c\u003d 18688. The same applies to vr * 128.\nWe know -1197 \u003c\u003d A * 64 * -16 \u003c\u003d -1192.\nbb \u003d -(ub * 128) + (A * 64 * -16) + 32 so bb \u003e\u003d -19853. bb \u003c 0 unless full range and ub \u003d 0, which is likely not the case. It\u0027s safe to store its negative in U16. The same applies to br.\n\nWe know ug \u003e\u003d -98, so -25088 \u003c\u003d ug * 128 + vg * 128 \u003c 0. bg \u003d -(ug * 128 + vg * 128) + (A * 64 * -16) + 32, so -1165 \u003c\u003d bg \u003c\u003d 23923. For all current colorspace bg \u003e 0 (it\u0027s true as long as ug + vg \u003e 9, which is likely the case). It\u0027s safe to store it in U16.\n\n\nFrom the analysis above, for this term table:\n        Y     UV                B\n    R   y1    u * ub            bb\n    G   y1    u * ug + v * vg   bg\n    B   y1    v * vr            br\n\nSign of each term are shown as below:\n        Y   UV   B\n    R   +   +    -\n    G   +   -   +/-\n    B   +   +    -\n\nFor R and B, Y part and UV part are both positive, and their sum is in range 0 \u003c\u003d sum \u003c\u003d 56307, so unsigned add is safe. B part is negative, a saturating sub is needed.\n\nFor G, Y part is positive, assuming B part is positive, their sum is in range 0 \u003c\u003d sum \u003c\u003d 44165, so unsigned add is safe. UV part is negative, a saturating sub is needed.",
      "revId": "d0b91d9aaf012c36abf3d388d1257dc54780be77",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "182a7340_ce1eb2b4",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-04-14T18:48:34Z",
      "side": 1,
      "message": "This analysis would be good to document.  Its a bit long for a comment (usually in row_common.cc), so adding it to one of the documents might be good?\nFor now I\u0027ll add it to the issue tracker 862\nhttps://bugs.chromium.org/p/libyuv/issues/detail?id\u003d862",
      "parentUuid": "c53ff9f9_d2cf7902",
      "revId": "d0b91d9aaf012c36abf3d388d1257dc54780be77",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4cea4882_cb15cfaa",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-04-14T18:48:34Z",
      "side": 1,
      "message": "Tested the basic I420ToARGB on a variety of CPUs\nWas\na53.txt:[       OK ] LibYUVConvertTest.I420ToARGB_Opt (2333 ms)\na55.txt:[       OK ] LibYUVConvertTest.I420ToARGB_Opt (3368 ms)\na72.txt:[       OK ] LibYUVConvertTest.I420ToARGB_Opt (1772 ms)\na73.txt:[       OK ] LibYUVConvertTest.I420ToARGB_Opt (1673 ms)\na75.txt:[       OK ] LibYUVConvertTest.I420ToARGB_Opt (1387 ms)\na76.txt:[       OK ] LibYUVConvertTest.I420ToARGB_Opt (1445 ms)\na77.txt:[       OK ] LibYUVConvertTest.I420ToARGB_Opt (1098 ms)\nkryo.txt:[       OK ] LibYUVConvertTest.I420ToARGB_Opt (1384 ms)\nm1.txt:[       OK ] LibYUVConvertTest.I420ToARGB_Opt (1698 ms)\nm3.txt:[       OK ] LibYUVConvertTest.I420ToARGB_Opt (1316 ms)\n\nNow\na53.txt:[       OK ] LibYUVConvertTest.I420ToARGB_Opt (1818 ms)\na55.txt:[       OK ] LibYUVConvertTest.I420ToARGB_Opt (2447 ms)\na72.txt:[       OK ] LibYUVConvertTest.I420ToARGB_Opt (1172 ms)\na73.txt:[       OK ] LibYUVConvertTest.I420ToARGB_Opt (1207 ms)\na75.txt:[       OK ] LibYUVConvertTest.I420ToARGB_Opt (900 ms)\na76.txt:[       OK ] LibYUVConvertTest.I420ToARGB_Opt (1011 ms)\na77.txt:[       OK ] LibYUVConvertTest.I420ToARGB_Opt (882 ms)\nkryo.txt:[       OK ] LibYUVConvertTest.I420ToARGB_Opt (1219 ms)\nm1.txt:[       OK ] LibYUVConvertTest.I420ToARGB_Opt (1285 ms)\nm3.txt:[       OK ] LibYUVConvertTest.I420ToARGB_Opt (1213 ms)\n",
      "revId": "d0b91d9aaf012c36abf3d388d1257dc54780be77",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "812c269c_b6fda6a6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 8
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-04-15T18:07:51Z",
      "side": 1,
      "message": "If ENABLE_SLOW_TESTS is enabled, there is a (preexisting) failure on ARM\n\n[ RUN      ] LibYUVConvertTest.ARGB1555ToI420_Any\nthird_party/libyuv/files/unit_test/convert_test.cc:1137: Failure\nExpected equality of these values:\n  dst_uv_c[i * kStrideUV + j]\n    Which is: \u0027\\x8B\u0027 (139)\n  dst_uv_opt[i * kStrideUV + j]\n    Which is: \u0027\\x92\u0027 (146)\n",
      "revId": "d0b91d9aaf012c36abf3d388d1257dc54780be77",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4736dd41_73eac783",
        "filename": "source/row_neon.cc",
        "patchSetId": 8
      },
      "lineNbr": 113,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-04-13T19:16:16Z",
      "side": 1,
      "message": "does this clamp hot colors correctly?\nthe old code treated these as s16 so if the limited range values were out of range, the underflow is considered a negative that will be clamped to 0.",
      "revId": "d0b91d9aaf012c36abf3d388d1257dc54780be77",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ba56fa43_80c67b6f",
        "filename": "source/row_neon.cc",
        "patchSetId": 8
      },
      "lineNbr": 113,
      "author": {
        "id": 1482051
      },
      "writtenOn": "2021-04-14T01:32:28Z",
      "side": 1,
      "message": "In my analysis, for any reasonable colorspace it can\u0027t overflow. (By saying reasonable I mean red primary actually looks reddish and so on.)\n\nIf you want, I can post my analysis here or put in the code somewhere.",
      "parentUuid": "4736dd41_73eac783",
      "revId": "d0b91d9aaf012c36abf3d388d1257dc54780be77",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c0bd4ce8_8d26e26b",
        "filename": "source/row_neon64.cc",
        "patchSetId": 8
      },
      "lineNbr": 126,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-04-13T19:16:16Z",
      "side": 1,
      "message": "is this right?  I was expecting unlimited data to do sub on green and add on r and b?",
      "revId": "d0b91d9aaf012c36abf3d388d1257dc54780be77",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "df067d85_b4850dfa",
        "filename": "source/row_neon64.cc",
        "patchSetId": 8
      },
      "lineNbr": 126,
      "author": {
        "id": 1482051
      },
      "writtenOn": "2021-04-14T01:32:28Z",
      "side": 1,
      "message": "First we add UV contribution to R and B, but add Bias to G. Then we sub Bias from R and B, sub UV contribution from G. In reasonable colorspace the first add won\u0027t overflow u16. Only the following sub needs saturating.",
      "parentUuid": "c0bd4ce8_8d26e26b",
      "revId": "d0b91d9aaf012c36abf3d388d1257dc54780be77",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7cb54544_eff5ad8d",
        "filename": "source/row_neon64.cc",
        "patchSetId": 8
      },
      "lineNbr": 126,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-04-14T18:48:34Z",
      "side": 1,
      "message": "With unsigned coefficients of the \u0027unlimited data\u0027, in the case of \u0027full range\u0027 colorspace, we have the ability to use 1.7 and 1.15 fixed point, representing 0 to 1.999, but with 1 additional bit of accuracy.\nIt would push the values closer to overflow.\nThe main code change to enable this is the final shift needs to be in the YuvConstants structure.\nIt doesnt need to be done, but this is a possible future quality improvement and it would be good if the math can allow for 1.15 without overflows",
      "parentUuid": "df067d85_b4850dfa",
      "revId": "d0b91d9aaf012c36abf3d388d1257dc54780be77",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6169139f_aacedd6c",
        "filename": "source/row_neon64.cc",
        "patchSetId": 8
      },
      "lineNbr": 126,
      "author": {
        "id": 1482051
      },
      "writtenOn": "2021-04-15T02:32:53Z",
      "side": 1,
      "message": "1.7 and 1.15 fix point is doable for full range colorspace, but that need another code path, using some signed intermediates and instructions.\n\nIt might be worth considering using different code paths for different  YuvConstants. I have an attempt to support unlimited data on Intel but has 5%-10% performance overhead. It would be good to give better performance / precision on possible YuvConstants.",
      "parentUuid": "7cb54544_eff5ad8d",
      "revId": "d0b91d9aaf012c36abf3d388d1257dc54780be77",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e608e6d6_bf1d3df0",
        "filename": "source/row_neon64.cc",
        "patchSetId": 8
      },
      "lineNbr": 126,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2021-04-15T19:12:54Z",
      "side": 1,
      "message": "This CL, for ARM, addresses the 2 largest quality issues on ARM.  The I444 subsampling, for I444.  No impact on I420 but a huge improvement on I444, which I expect is used a bit more today than in the past.\nAs codecs improve, we rely less on resolution and subsampling and let the codec do it.\n\nThe 2.6 is a bit of an issue, depending on the colorspace.  In practice its not too bad for full range, but some of the limited range coefficients had more rounding error.\nI experimented on Intel with a shift vs multiply for the final / 64.  Shift is faster.  But if a multiply is used, then fixed point does not need to be used... each channel can have normalized coefficients to maximize accuracy within the final 16 bit values.  e.g.  instead of /64 or /128, it could be /100 providing a bit more accuracy than /64 and still enough range for limited range coefficients.\nif float or fp16 become important, a float YUV to RGB could be done with a convert to fp16.  But it would hurt performance if conversion to/from int were used.\n\nThe original way this yuv to rgb was written was 3 tables of contributions from each yuv component, to rgb.  roughly\nrgb +\u003d yrgb[y]\nrgb +\u003d urgb[u]\nrgb +\u003d vrgb[v]\nrgb \u003e\u003e\u003d 6\nIt had 2 drawbacks:\n1 table cache misses\n2 its not simd.  it produces 1 pixel at a time.\nbut simd can do table look ups today with a vtbl / vpshufb.  Just not quite big enough.  arm can do a 64 byte table.  intel can do 128 byte.\n\nThe 8 bit math on chroma is probably the next biggest issue on 10 bit.  The chroma bits are simply reduced to 8 bit.\nFull 16 bit multiplies will be needed, similar to the Y channel.\nThere will need to be READ macros that convert 10 bit to 16 bit instead of down to 8 bit.",
      "parentUuid": "6169139f_aacedd6c",
      "revId": "d0b91d9aaf012c36abf3d388d1257dc54780be77",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}