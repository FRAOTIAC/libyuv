{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "02d6c23d_c11be588",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1001562
      },
      "writtenOn": "2023-06-16T17:36:45Z",
      "side": 1,
      "message": "The LibYUVPlanarTest.ARGBUnattenuate_* tests failed. I understand this change was committed to Google\u0027s internal repository first. Did the tests pass there?",
      "revId": "97808bd62a761451f73485310746feb9dbcae884",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d373df7b_5e92de4d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2023-06-16T18:01:38Z",
      "side": 1,
      "message": "yes, but testing is hard. Tests were passing with exact but not without.  also need to test avx vs sse by running with LIBYUV_DISABLE_AVX2\u003d1\n\nI had tightened up EXPECTED_ATTENUATE_DIFF to 0 and that works on all cpus for the attenuate tests, but the same macro was used for unattenuate, which still has a difference when exact is not on.  Which is odd because the is only SSE and C?  I\u0027ll need to follow up.\nexact needs to go away.  There is just ARGBToUV and Unattenuate now.\n\nwith LIBYUV_EXACT on Skylake Xeon\nWas C\nARGBAttenuate_Opt (1125 ms)\nNow AVX2\nARGBAttenuate_Opt (304 ms)\nSSSE3\nARGBAttenuate_Opt (421 ms)",
      "parentUuid": "02d6c23d_c11be588",
      "revId": "97808bd62a761451f73485310746feb9dbcae884",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}